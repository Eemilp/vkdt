#version 460
#extension GL_GOOGLE_include_directive    : enable
#include "shared.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 1) uniform params_t
{
  int primaries;
  int trc;
} params;

layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;

  // if(params.trc == 0) // linear
  if(params.trc == 1) // 709
  {
    const float a = 1.09929682680944;
    const float b = 0.018053968510807;
    rgb = mix(rgb/4.5, pow((rgb+(a-1))/a, vec3(2.2)), greaterThan(rgb, vec3(b*4.5)));
  }
  else if(params.trc == 2) // sRGB
  { // undo tone curve
    rgb = mix(rgb/12.92, pow((rgb+0.055)/1.055, vec3(2.4)), greaterThan(rgb, vec3(0.04045)));
  }
  else if(params.trc == 3) // PQ
  { // eotf
    const float m1 = 1305.0/8192.0;
    const float m2 = 2523.0/32.0;
    const float c1 = 107.0/128.0;
    const float c2 = 2413.0/128.0;
    const float c3 = 2392.0/128.0;
    const vec3 xpow = pow(max(vec3(0.0), rgb), vec3(1.0/m2));
    const vec3 num = max(xpow - c1, vec3(0.0));
    const vec3 den = max(c2 - c3 * xpow, 1e-10);
    rgb = pow(num/den, vec3(1.0/m1));
  }
  else if(params.trc == 4) // DCI
  {
    rgb = pow(rgb, vec3(2.6));
  }
  else if(params.trc == 5) // HLG
  {
    const float r = 1.0; // reference white
    const float a = 0.17883277, b = /*1.0 - 4.0*a =*/ 0.28466892, c = /*0.5 - a*log(4.0*a) =*/ 0.55991073;
    // zscale says:
    rgb = mix((exp((rgb-c)/a) + b)/12.0, rgb*rgb/3.0, lessThanEqual(rgb, vec3(0.5)));
  }
  else if(params.trc == 6) // gamma
  { // TODO get gamma from params
    rgb = pow(rgb, vec3(2.2)); // happens to be adobe rgb
  }

  if(params.primaries == 0)
  { // TODO: use uploaded custom matrix?
  }
  else if(params.primaries == 1) // srgb
  { // convert linear rec709 to linear rec2020
    const mat3 M = mat3(
      0.62750375, 0.06910828, 0.01639406,
      0.32927542, 0.91951916, 0.08801125,
      0.04330266, 0.0113596 , 0.89538035);
    rgb = M * rgb;
  }
  // else if(params.primaries == 2) // 2020 and 2100
  // { // identity 
  // }
  else if(params.primaries == 3) // adobeRGB
  {
    const mat3 rec2020_to_adobeRGB = mat3(
        0.87736306, 0.0966218 , 0.02291617,
        0.07751751, 0.89152263, 0.04301452,
        0.04516292, 0.01186405, 0.93367996);
    rgb = rec2020_to_adobeRGB * rgb;
  }
  else if(params.primaries == 4) // P3
  {
    const mat3 rec2020_to_display_P3 = mat3(
        0.75386031,  0.04575344, -0.00121501,
        0.19861268,  0.94178472,  0.01760596,
        0.04757049,  0.01247032,  0.98321971);
    rgb = rec2020_to_display_P3 * rgb;
  }
  else if(params.primaries == 5) // XYZ
  {
    const mat3 xyz_to_rec2020 = mat3(
      1.71665119, -0.66668435,  0.01763986,
     -0.35567078,  1.61648124, -0.04277061,
     -0.25336628,  0.01576855,  0.94210312);
    rgb = xyz_to_rec2020 * rgb;
  }

  imageStore(img_out, ipos, vec4(rgb, 1.0));
}
