#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 0) uniform global_t
{
  uint frame;
} global;
layout(std140, set = 0, binding = 1) uniform params_t
{
  int generate;
} params;
layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform sampler2D img_rfi;
layout(set = 1, binding = 2) uniform writeonly image2D img_out;
layout(set = 1, binding = 3) uniform writeonly image2D img_rfo;
layout(std430, set = 1, binding = 4) writeonly buffer ssbo_nab_t { float noise_a; float noise_b; } ssbo_nab; // noise profile a b

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  ivec2 rpos = ipos;
  int flip = 0;
  ivec2 off = ivec2(0);
  float ev = 0;

  // uint seed = 123456789+133700 * (global.frame/500);
  uint seed = 123456789+133700 * global.frame;
  if(params.generate != 0)
  {
    ev = -2.0 + 4.0*mrand(seed);
    flip = int(4.0*mrand(seed));
    off = ivec2(textureSize(img_in, 0) * vec2(mrand(seed), mrand(seed)));
  }

  if((flip & 1) != 0) rpos.x = imageSize(img_out).x - 1 - ipos.x;
  if((flip & 2) != 0) rpos.y = imageSize(img_out).y - 1 - ipos.y;
  ivec2 tci = rpos+off;
  vec2 tc = (tci + 0.5)/vec2(textureSize(img_in, 0));
  vec4 rgb = texture(img_in,  tc);
  vec4 ref = texture(img_rfi, tc);
  rgb *= pow(2.0, ev);
  ref *= pow(2.0, ev);

  float noise_a = 0.0;
  float noise_b = 0.0;

  if(params.generate == 2)
  { // add noise according to gaussian/poissonian profile
    // sample noise a/b based on per-frame seed
    const float scale = 65535.0;
    noise_a = 100.0 * scale * mrand(seed);
    noise_b = 1000.0 * mrand(seed);
    seed += 7654*ipos.x + 1357900*ipos.y;
    seed = uint((1<<29)*mrand(seed));
    vec4 z = vec4(warp_gaussian(vec2(mrand(seed), mrand(seed))),
                  warp_gaussian(vec2(mrand(seed), mrand(seed))));
    rgb.rgb = ref.rgb + z.rgb * sqrt(noise_a + scale*max(ref.rgb, vec3(0))*noise_b)/scale;
  }

  if(ipos.x == 0 && ipos.y == 0)
  { // pass on to training in kpn-t
    ssbo_nab.noise_a = noise_a;
    ssbo_nab.noise_b = noise_b;
  }
  
  rgb.w = ref.w = 1.0;
  imageStore(img_out, ipos, rgb);
  imageStore(img_rfo, ipos, ref);
}
