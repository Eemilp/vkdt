#version 460
#extension GL_GOOGLE_include_directive    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  ivec2 corner_lt;
  ivec2 corner_rb;
  vec2 map_origin;
  vec2 map_scale;
} push;

layout( // input f16 buffer rgb
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // output f16 buffer rgb
    set = 1, binding = 1
) uniform writeonly image2D img_out;

layout( // GainMap data
    set = 1, binding = 2
) uniform sampler2D gainmap_in;

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  // only apply operation within specified bounds
  if(any(lessThan(ipos, push.corner_lt))) return;
  if(any(greaterThanEqual(ipos, push.corner_rb))) return;

  // pixel location as a fraction of the entire image
  vec2 pos = (0.5 + ipos) / imageSize(img_out);
  // pixel location relative to the GainMap which might not cover the entire image
  // points outside the map use the nearest value at the edge of the map
  pos = clamp((pos * push.map_scale) - push.map_origin, 0., 1.);
  // get the gains for all channels at this point
  vec4 gains = texture(gainmap_in, pos);
  // select and apply the appropriate gain for this Bayer filter
  float gain = gains[(ipos.x & 1) + (ipos.y & 1) * 2];
  float v = texelFetch(img_in, ipos, 0).r;
  imageStore(img_out, ipos, vec4(v * gain, 0., 0., 0.));
}
